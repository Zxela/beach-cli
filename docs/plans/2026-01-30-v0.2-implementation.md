# Vanbeach v0.2 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Transform Vanbeach into a visually impressive, accurate beach planning tool with tide visualization, fixed recommendations, and live updates.

**Architecture:** Incremental enhancement of existing ratatui TUI. Add sparkline widget for tides, refactor scoring engine for sanity gates, introduce background refresh via tokio channels.

**Tech Stack:** Rust, ratatui 0.28, tokio, chrono, crossterm

---

## Phase 1: Bug Fixes (Critical Recommendation Issues)

### Task 1: Fix Sunset Recommendations After Sunset

**Files:**
- Modify: `src/ui/beach_detail.rs:519-616` (compute_best_windows_from_hour)
- Test: `src/ui/beach_detail.rs` (existing test module)

**Step 1: Write the failing test**

Add to the test module in `src/ui/beach_detail.rs`:

```rust
#[test]
fn test_sunset_activity_excludes_hours_after_sunset() {
    // Create conditions with sunset at 17:00
    let conditions = create_test_conditions_with_sunset(17, 0);

    // Start from hour 6 to see all hours
    let windows = compute_best_windows_from_hour(Activity::Sunset, &conditions, 6);

    // No window should include hours after sunset (17)
    for window in &windows {
        assert!(
            window.end_hour <= 18, // Allow up to hour 18 (ending at 18:00 means last scored hour is 17)
            "Sunset window should not extend past sunset hour. Got end_hour={}",
            window.end_hour
        );
    }
}

#[test]
fn test_sunset_activity_returns_empty_when_past_sunset() {
    // Create conditions with sunset at 17:00
    let conditions = create_test_conditions_with_sunset(17, 0);

    // Start from hour 18 (after sunset)
    let windows = compute_best_windows_from_hour(Activity::Sunset, &conditions, 18);

    // Should return empty since all viable hours have passed
    assert!(
        windows.is_empty(),
        "Should have no windows when starting after sunset"
    );
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test test_sunset_activity_excludes_hours_after_sunset -p vanbeach -- --nocapture`
Expected: FAIL - windows extend past sunset

**Step 3: Implement the fix**

In `compute_best_windows_from_hour`, add sunset filtering for Sunset activity:

```rust
fn compute_best_windows_from_hour(
    activity: Activity,
    conditions: &crate::data::BeachConditions,
    current_hour: u8,
) -> Vec<TimeWindow> {
    let profile = get_profile(activity);

    // Get weather data for scoring
    let (temp, wind, uv) = match &conditions.weather {
        Some(w) => (w.temperature as f32, w.wind as f32, w.uv as f32),
        None => return vec![],
    };

    // Get sunset hour for filtering and dynamic scoring
    let sunset_hour = conditions
        .weather
        .as_ref()
        .map(|w| w.sunset.hour() as u8)
        .unwrap_or(20);

    // For Sunset activity, cap end_hour at sunset_hour
    let effective_end_hour = if activity == Activity::Sunset {
        sunset_hour.min(21)
    } else {
        21
    };

    // If we're already past the effective end hour, no windows available
    if current_hour > effective_end_hour {
        return vec![];
    }

    // ... rest of scoring logic, but use effective_end_hour instead of 21 ...
```

Update the loop in `compute_best_windows_from_hour`:

```rust
    let start_hour = current_hour.max(6);
    let mut hourly_scores: Vec<(u8, u8)> = Vec::new();

    // Use effective_end_hour for sunset, 21 for others
    for hour in start_hour..=effective_end_hour {
        // ... existing scoring code ...
    }
```

**Step 4: Run tests to verify they pass**

Run: `cargo test test_sunset_activity -p vanbeach -- --nocapture`
Expected: PASS

**Step 5: Commit**

```bash
git add src/ui/beach_detail.rs
git commit -m "fix: exclude hours after sunset from sunset recommendations

Sunset activity now filters out hours after the actual sunset time,
preventing nonsensical recommendations like 'watch sunset at 9pm'
when sunset is at 5pm.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

### Task 2: Add Weather Sanity Gates to Scoring

**Files:**
- Modify: `src/activities.rs` (add sanity gate checks)
- Test: `src/activities.rs` (existing test module)

**Step 1: Write the failing tests**

Add to `src/activities.rs` tests:

```rust
#[test]
fn test_swimming_blocked_when_raining() {
    let profile = get_profile(Activity::Swimming);
    // Rain weather code = should block
    let score = profile.score_time_slot_with_weather_code(
        12, "test", 24.0, 5.0, 5.0,
        WaterStatus::Safe, 2.4, 4.8, 0.3,
        Some(61), // Light rain weather code
    );
    assert_eq!(score.score, 0, "Swimming should be blocked during rain");
    assert!(score.blocked, "Should be marked as blocked");
}

#[test]
fn test_swimming_blocked_when_cold() {
    let profile = get_profile(Activity::Swimming);
    let score = profile.score_time_slot_with_weather_code(
        12, "test", 12.0, 5.0, 5.0, // 12°C - too cold
        WaterStatus::Safe, 2.4, 4.8, 0.3,
        Some(0), // Clear weather
    );
    assert_eq!(score.score, 0, "Swimming should be blocked when temp < 15°C");
}

#[test]
fn test_sunbathing_blocked_when_overcast() {
    let profile = get_profile(Activity::Sunbathing);
    let score = profile.score_time_slot_with_weather_code(
        12, "test", 25.0, 5.0, 5.0,
        WaterStatus::Safe, 2.4, 4.8, 0.3,
        Some(3), // Overcast weather code
    );
    assert_eq!(score.score, 0, "Sunbathing should be blocked when overcast");
}

#[test]
fn test_sailing_blocked_when_dangerous_wind() {
    let profile = get_profile(Activity::Sailing);
    let score = profile.score_time_slot_with_weather_code(
        12, "test", 20.0, 45.0, 3.0, // 45 km/h wind - dangerous
        WaterStatus::Safe, 4.0, 4.8, 0.3,
        Some(0),
    );
    assert_eq!(score.score, 0, "Sailing should be blocked when wind > 40 km/h");
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo test test_swimming_blocked -p vanbeach`
Expected: FAIL - method doesn't exist yet

**Step 3: Add blocked field to TimeSlotScore and sanity gate method**

In `src/activities.rs`, update `TimeSlotScore`:

```rust
#[derive(Debug, Clone)]
#[allow(dead_code)]
pub struct TimeSlotScore {
    pub hour: u8,
    pub beach_id: String,
    pub activity: Activity,
    pub score: u8,
    pub factors: ScoreFactors,
    /// Whether this time slot is blocked by a sanity gate
    pub blocked: bool,
    /// Reason for blocking, if blocked
    pub block_reason: Option<String>,
}
```

Add the sanity gate method to `ActivityProfile`:

```rust
impl ActivityProfile {
    /// Checks weather sanity gates. Returns (blocked, reason) if blocked.
    pub fn check_sanity_gates(
        &self,
        temp: f32,
        wind: f32,
        weather_code: Option<u8>,
    ) -> Option<String> {
        // Weather code meanings (Open-Meteo WMO codes):
        // 0: Clear, 1-3: Partly cloudy to overcast
        // 51-67: Drizzle/Rain, 71-77: Snow, 80-82: Showers
        // 95-99: Thunderstorm

        let is_rain = weather_code.map(|c| (51..=67).contains(&c) || (80..=82).contains(&c)).unwrap_or(false);
        let is_thunderstorm = weather_code.map(|c| (95..=99).contains(&c)).unwrap_or(false);
        let is_overcast = weather_code.map(|c| c == 3).unwrap_or(false);
        let is_snow = weather_code.map(|c| (71..=77).contains(&c)).unwrap_or(false);

        match self.activity {
            Activity::Swimming => {
                if temp < 15.0 {
                    return Some("Too cold for swimming".to_string());
                }
                if is_rain || is_thunderstorm {
                    return Some("Rain - not suitable for swimming".to_string());
                }
            }
            Activity::Sunbathing => {
                if temp < 18.0 {
                    return Some("Too cold for sunbathing".to_string());
                }
                if is_rain || is_overcast {
                    return Some("Overcast - not suitable for sunbathing".to_string());
                }
            }
            Activity::Sailing => {
                if wind > 40.0 {
                    return Some("Dangerous wind conditions".to_string());
                }
                if is_thunderstorm {
                    return Some("Thunderstorm - sailing dangerous".to_string());
                }
            }
            _ => {}
        }

        // Universal blocks
        if is_thunderstorm || is_snow {
            return Some("Severe weather conditions".to_string());
        }

        None
    }

    /// Score with weather code for sanity gate checking
    #[allow(clippy::too_many_arguments)]
    pub fn score_time_slot_with_weather_code(
        &self,
        hour: u8,
        beach_id: &str,
        temp: f32,
        wind: f32,
        uv: f32,
        water_status: WaterStatus,
        tide_height: f32,
        max_tide: f32,
        crowd_level: f32,
        weather_code: Option<u8>,
    ) -> TimeSlotScore {
        // Check sanity gates first
        if let Some(reason) = self.check_sanity_gates(temp, wind, weather_code) {
            return TimeSlotScore {
                hour,
                beach_id: beach_id.to_string(),
                activity: self.activity,
                score: 0,
                factors: ScoreFactors {
                    temperature: 0.0,
                    water_quality: 0.0,
                    wind: 0.0,
                    uv: 0.0,
                    tide: 0.0,
                    crowd: 0.0,
                    time_of_day: 0.0,
                },
                blocked: true,
                block_reason: Some(reason),
            };
        }

        // Normal scoring if not blocked
        let mut score = self.score_time_slot(
            hour, beach_id, temp, wind, uv, water_status, tide_height, max_tide, crowd_level,
        );
        score.blocked = false;
        score.block_reason = None;
        score
    }
}
```

Update the original `score_time_slot` to include new fields:

```rust
// At the end of score_time_slot, change the return:
TimeSlotScore {
    hour,
    beach_id: beach_id.to_string(),
    activity: self.activity,
    score,
    factors,
    blocked: false,
    block_reason: None,
}
```

**Step 4: Run tests to verify they pass**

Run: `cargo test test_swimming_blocked -p vanbeach && cargo test test_sunbathing_blocked -p vanbeach && cargo test test_sailing_blocked -p vanbeach`
Expected: PASS

**Step 5: Commit**

```bash
git add src/activities.rs
git commit -m "feat: add weather sanity gates to scoring engine

Activities now have hard blockers:
- Swimming: blocked if temp < 15°C or raining
- Sunbathing: blocked if temp < 18°C or overcast
- Sailing: blocked if wind > 40 km/h or thunderstorm
- All: blocked during severe weather (thunderstorm, snow)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

### Task 3: Handle Water Quality Data Staleness

**Files:**
- Modify: `src/data/mod.rs` (add staleness check to WaterQuality)
- Modify: `src/activities.rs` (penalize stale water quality)
- Test: Both files

**Step 1: Write the failing tests**

In `src/data/mod.rs` tests:

```rust
#[test]
fn test_water_quality_is_stale_after_48_hours() {
    let old_date = NaiveDate::from_ymd_opt(2026, 1, 28).unwrap(); // 2 days ago
    let wq = WaterQuality {
        status: WaterStatus::Safe,
        ecoli_count: Some(50),
        sample_date: old_date,
        advisory_reason: None,
        fetched_at: Utc::now(),
    };

    // Assuming today is 2026-01-30
    assert!(wq.is_stale(), "Water quality from 2+ days ago should be stale");
}

#[test]
fn test_water_quality_not_stale_within_48_hours() {
    let recent_date = NaiveDate::from_ymd_opt(2026, 1, 29).unwrap(); // Yesterday
    let wq = WaterQuality {
        status: WaterStatus::Safe,
        ecoli_count: Some(50),
        sample_date: recent_date,
        advisory_reason: None,
        fetched_at: Utc::now(),
    };

    assert!(!wq.is_stale(), "Water quality from yesterday should not be stale");
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo test test_water_quality_is_stale -p vanbeach`
Expected: FAIL - method doesn't exist

**Step 3: Implement staleness check**

In `src/data/mod.rs`, add to `WaterQuality`:

```rust
impl WaterQuality {
    /// Returns true if the water quality data is stale (sample > 48 hours old)
    pub fn is_stale(&self) -> bool {
        let today = chrono::Local::now().date_naive();
        let days_old = (today - self.sample_date).num_days();
        days_old > 2
    }

    /// Returns true if the water quality data is very stale (sample > 7 days old)
    pub fn is_very_stale(&self) -> bool {
        let today = chrono::Local::now().date_naive();
        let days_old = (today - self.sample_date).num_days();
        days_old > 7
    }

    /// Returns the effective status, downgrading to Unknown if stale
    pub fn effective_status(&self) -> WaterStatus {
        if self.is_stale() {
            WaterStatus::Unknown
        } else {
            self.status
        }
    }
}
```

**Step 4: Run tests to verify they pass**

Run: `cargo test test_water_quality -p vanbeach`
Expected: PASS

**Step 5: Commit**

```bash
git add src/data/mod.rs
git commit -m "feat: add staleness detection to water quality data

Water quality now tracks staleness:
- is_stale(): true if sample > 48 hours old
- is_very_stale(): true if sample > 7 days old
- effective_status(): returns Unknown if stale

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Phase 2: Home Screen Redesign

### Task 4: Create Tide Sparkline Widget

**Files:**
- Create: `src/ui/widgets/mod.rs`
- Create: `src/ui/widgets/sparkline.rs`
- Modify: `src/ui/mod.rs` (add widgets module)
- Test: `src/ui/widgets/sparkline.rs`

**Step 1: Write the failing test**

Create `src/ui/widgets/sparkline.rs`:

```rust
//! Tide sparkline widget for inline visualization

use ratatui::{
    buffer::Buffer,
    layout::Rect,
    style::{Color, Style},
    widgets::Widget,
};

/// Block characters for different tide heights (8 levels)
const BLOCKS: [char; 8] = ['▁', '▂', '▃', '▄', '▅', '▆', '▇', '█'];

/// A sparkline widget showing tide heights over time
pub struct TideSparkline<'a> {
    /// Tide heights for each time slot
    heights: &'a [f64],
    /// Maximum tide height for normalization
    max_height: f64,
    /// Current position marker (index into heights)
    current_position: Option<usize>,
    /// Style for the sparkline
    style: Style,
    /// Style for the current position marker
    marker_style: Style,
}

impl<'a> TideSparkline<'a> {
    pub fn new(heights: &'a [f64], max_height: f64) -> Self {
        Self {
            heights,
            max_height,
            current_position: None,
            style: Style::default().fg(Color::Cyan),
            marker_style: Style::default().fg(Color::Yellow),
        }
    }

    pub fn current_position(mut self, pos: usize) -> Self {
        self.current_position = Some(pos);
        self
    }

    pub fn style(mut self, style: Style) -> Self {
        self.style = style;
        self
    }

    fn height_to_block(&self, height: f64) -> char {
        let normalized = (height / self.max_height).clamp(0.0, 1.0);
        let index = ((normalized * 7.0).round() as usize).min(7);
        BLOCKS[index]
    }
}

impl<'a> Widget for TideSparkline<'a> {
    fn render(self, area: Rect, buf: &mut Buffer) {
        if area.width == 0 || area.height == 0 {
            return;
        }

        let width = area.width as usize;

        for (i, height) in self.heights.iter().take(width).enumerate() {
            let block = self.height_to_block(*height);
            let x = area.x + i as u16;
            let y = area.y;

            let style = if self.current_position == Some(i) {
                self.marker_style
            } else {
                self.style
            };

            buf.get_mut(x, y).set_char(block).set_style(style);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_height_to_block_minimum() {
        let sparkline = TideSparkline::new(&[], 4.8);
        assert_eq!(sparkline.height_to_block(0.0), '▁');
    }

    #[test]
    fn test_height_to_block_maximum() {
        let sparkline = TideSparkline::new(&[], 4.8);
        assert_eq!(sparkline.height_to_block(4.8), '█');
    }

    #[test]
    fn test_height_to_block_mid() {
        let sparkline = TideSparkline::new(&[], 4.8);
        let block = sparkline.height_to_block(2.4); // 50%
        assert!(BLOCKS.contains(&block));
    }

    #[test]
    fn test_sparkline_creation() {
        let heights = vec![1.0, 2.0, 3.0, 4.0, 3.0, 2.0, 1.0];
        let sparkline = TideSparkline::new(&heights, 4.8)
            .current_position(3)
            .style(Style::default().fg(Color::Blue));

        assert_eq!(sparkline.heights.len(), 7);
        assert_eq!(sparkline.current_position, Some(3));
    }
}
```

**Step 2: Create module file**

Create `src/ui/widgets/mod.rs`:

```rust
//! Custom widgets for the beach CLI

mod sparkline;

pub use sparkline::TideSparkline;
```

**Step 3: Update ui/mod.rs**

Add to `src/ui/mod.rs`:

```rust
pub mod widgets;
```

**Step 4: Run tests to verify they pass**

Run: `cargo test sparkline -p vanbeach`
Expected: PASS

**Step 5: Commit**

```bash
git add src/ui/widgets/mod.rs src/ui/widgets/sparkline.rs src/ui/mod.rs
git commit -m "feat: add TideSparkline widget for inline tide visualization

Custom ratatui widget that renders tide heights as unicode block
characters (▁▂▃▄▅▆▇█) with optional current position marker.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

### Task 5: Add Smart Header to Beach List

**Files:**
- Modify: `src/ui/beach_list.rs` (add header section)
- Modify: `src/app.rs` (add method to find best beach now)
- Test: Both files

**Step 1: Write the failing test**

In `src/app.rs` tests:

```rust
#[test]
fn test_find_best_beach_now_returns_none_without_activity() {
    let app = App::new();
    assert!(app.find_best_beach_now().is_none());
}

#[test]
fn test_find_best_beach_now_returns_beach_with_activity() {
    let mut app = App::new();
    app.current_activity = Some(Activity::Swimming);
    // Would need mock conditions to fully test
    // For now, just verify method exists and runs without panic
    let _ = app.find_best_beach_now();
}
```

**Step 2: Implement find_best_beach_now in App**

In `src/app.rs`:

```rust
/// Information about the best beach right now
#[derive(Debug, Clone)]
pub struct BestBeachNow {
    pub beach_name: String,
    pub beach_id: String,
    pub score: u8,
    pub reasons: Vec<String>,
}

impl App {
    /// Finds the best beach for the current activity right now
    pub fn find_best_beach_now(&self) -> Option<BestBeachNow> {
        let activity = self.current_activity?;
        let current_hour = chrono::Local::now().hour() as u8;

        let profile = crate::activities::get_profile(activity);
        let beaches = all_beaches();

        let mut best: Option<BestBeachNow> = None;
        let mut best_score: u8 = 70; // Minimum threshold

        for beach in beaches {
            let conditions = self.get_conditions(beach.id)?;

            // Skip if water quality is stale for swimming
            if activity == crate::activities::Activity::Swimming {
                if let Some(wq) = &conditions.water_quality {
                    if wq.is_stale() {
                        continue;
                    }
                }
            }

            let weather = conditions.weather.as_ref()?;
            let temp = weather.temperature as f32;
            let wind = weather.wind as f32;
            let uv = weather.uv as f32;

            let water_status = conditions
                .water_quality
                .as_ref()
                .map(|wq| wq.effective_status())
                .unwrap_or(crate::data::WaterStatus::Unknown);

            let (tide_height, max_tide) = conditions
                .tides
                .as_ref()
                .map(|t| (t.current_height as f32, 4.8f32))
                .unwrap_or((2.4, 4.8));

            let crowd = crate::crowd::estimate_crowd_level(current_hour);

            let score_result = profile.score_time_slot(
                current_hour, beach.id, temp, wind, uv, water_status,
                tide_height, max_tide, crowd,
            );

            if score_result.score > best_score {
                best_score = score_result.score;

                let mut reasons = Vec::new();
                reasons.push(format!("{:.0}°C", temp));
                if wind < 10.0 {
                    reasons.push("calm winds".to_string());
                }
                if water_status == crate::data::WaterStatus::Safe {
                    reasons.push("safe water".to_string());
                }

                best = Some(BestBeachNow {
                    beach_name: beach.name.to_string(),
                    beach_id: beach.id.to_string(),
                    score: score_result.score,
                    reasons,
                });
            }
        }

        best
    }
}
```

**Step 3: Run tests**

Run: `cargo test find_best_beach -p vanbeach`
Expected: PASS

**Step 4: Commit**

```bash
git add src/app.rs
git commit -m "feat: add find_best_beach_now() method to App

Returns the best beach for the current activity with score >= 70,
including reasons (temperature, wind, water status).

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

### Task 6: Render Smart Header in Beach List

**Files:**
- Modify: `src/ui/beach_list.rs`

**Step 1: Update render_beach_list to include header**

In `src/ui/beach_list.rs`, update the layout and add header rendering:

```rust
pub fn render_beach_list(frame: &mut Frame, app: &App) {
    let area = frame.area();

    // Create main layout with header, content area, and help text
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(4), // Smart header
            Constraint::Min(3),    // Beach list
            Constraint::Length(2), // Help text + data freshness
        ])
        .split(area);

    // Render smart header
    render_smart_header(frame, app, chunks[0]);

    // Render the beach list
    render_list(frame, app, chunks[1]);

    // Render help and status
    render_help_and_status(frame, app, chunks[2]);
}

fn render_smart_header(frame: &mut Frame, app: &App, area: Rect) {
    let now = Local::now();
    let time_str = now.format("%a %b %d, %H:%M").to_string();

    // Get current weather from first beach with data
    let current_temp = app.beach_conditions.values()
        .find_map(|c| c.weather.as_ref())
        .map(|w| format!("{:.0}°C {}", w.temperature, weather_icon(&w.condition)))
        .unwrap_or_else(|| "--°C".to_string());

    // Get sunset time
    let sunset_info = app.beach_conditions.values()
        .find_map(|c| c.weather.as_ref())
        .map(|w| {
            let now_time = now.time();
            let sunset = w.sunset;
            let mins_until = (sunset.hour() * 60 + sunset.minute()) as i32
                - (now_time.hour() * 60 + now_time.minute()) as i32;
            if mins_until > 0 {
                let hours = mins_until / 60;
                let mins = mins_until % 60;
                if hours > 0 {
                    format!("Sunset in {}h {}m", hours, mins)
                } else {
                    format!("Sunset in {}m", mins)
                }
            } else {
                "Sunset passed".to_string()
            }
        })
        .unwrap_or_default();

    // Build header lines
    let mut lines = vec![
        Line::from(vec![
            Span::styled("VANBEACH", Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)),
            Span::raw(format!("                         {} {}", time_str, current_temp)),
        ]),
        Line::from(Span::styled(
            "═".repeat(area.width as usize - 2),
            Style::default().fg(Color::DarkGray),
        )),
    ];

    // Best beach recommendation
    if let Some(best) = app.find_best_beach_now() {
        lines.push(Line::from(vec![
            Span::styled("★ ", Style::default().fg(Color::Yellow)),
            Span::styled("Best right now: ", Style::default().fg(Color::White)),
            Span::styled(&best.beach_name, Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)),
            Span::styled(
                format!(" — {}", best.reasons.join(", ")),
                Style::default().fg(Color::Gray),
            ),
        ]));
    } else if app.current_activity.is_some() {
        lines.push(Line::from(Span::styled(
            "No great options right now — check back later",
            Style::default().fg(Color::DarkGray),
        )));
    } else {
        lines.push(Line::from(Span::styled(
            "Press 1-5 to select an activity for recommendations",
            Style::default().fg(Color::DarkGray),
        )));
    }

    // Sunset/tide info
    if !sunset_info.is_empty() {
        lines.push(Line::from(Span::styled(
            format!("  {}", sunset_info),
            Style::default().fg(Color::DarkGray),
        )));
    }

    let paragraph = Paragraph::new(lines);
    frame.render_widget(paragraph, area);
}
```

**Step 2: Test manually**

Run: `cargo run`
Verify: Header shows with time, temp, and recommendation

**Step 3: Commit**

```bash
git add src/ui/beach_list.rs
git commit -m "feat: add smart header to beach list screen

Header shows:
- App name, current time, and temperature
- Best beach recommendation with reasons (when activity selected)
- Sunset countdown

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

### Task 7: Add Inline Tide Sparklines to Beach List

**Files:**
- Modify: `src/ui/beach_list.rs`
- Modify: `src/data/tides.rs` (add method to get hourly heights)

**Step 1: Add hourly tide height generation**

In `src/data/tides.rs`, add a method to generate hourly heights:

```rust
impl TideInfo {
    /// Generates estimated tide heights for hours 6am-9pm (16 hours)
    /// Returns a vector of 16 heights, one per hour
    pub fn hourly_heights(&self, max_height: f64) -> Vec<f64> {
        // Simplified sinusoidal tide model
        // Real implementation would interpolate from actual tide events
        let mut heights = Vec::with_capacity(16);

        for hour in 6..=21 {
            // Simple sine wave approximation (two tides per day)
            // Phase based on next_high time
            let phase = self.next_high
                .as_ref()
                .map(|h| h.time.hour() as f64)
                .unwrap_or(12.0);

            let t = (hour as f64 - phase) * std::f64::consts::PI / 6.0;
            let height = (max_height / 2.0) * (1.0 + t.cos());
            heights.push(height.clamp(0.0, max_height));
        }

        heights
    }
}
```

**Step 2: Update beach list to show sparklines**

In `src/ui/beach_list.rs`, update the list rendering to include sparklines:

```rust
fn render_list(frame: &mut Frame, app: &App, area: Rect) {
    let beaches = all_beaches();
    let mut lines: Vec<Line> = Vec::with_capacity(beaches.len());
    let current_hour = Local::now().hour() as usize;
    let sparkline_pos = if current_hour >= 6 && current_hour <= 21 {
        Some(current_hour - 6)
    } else {
        None
    };

    for (index, beach) in beaches.iter().enumerate() {
        let is_selected = index == app.selected_index;
        let conditions = app.get_conditions(beach.id);

        let cursor = if is_selected { "▸ " } else { "  " };

        // Temperature and weather
        let (temp_str, temp_color) = match conditions.and_then(|c| c.weather.as_ref()) {
            Some(weather) => (
                format!("{:>3}°", weather.temperature.round() as i32),
                temperature_color(weather.temperature),
            ),
            None => ("--°".to_string(), Color::Gray),
        };

        let weather_icon_str = match conditions.and_then(|c| c.weather.as_ref()) {
            Some(weather) => weather_icon(&weather.condition),
            None => "?",
        };

        // Water status
        let (water_icon_str, water_color) = match conditions.and_then(|c| c.water_quality.as_ref()) {
            Some(wq) => (
                water_status_icon(&wq.status),
                water_status_color(&wq.status),
            ),
            None => ("⚪", Color::Gray),
        };

        // Tide sparkline
        let tide_sparkline = match conditions.and_then(|c| c.tides.as_ref()) {
            Some(tides) => {
                let heights = tides.hourly_heights(4.8);
                heights.iter()
                    .enumerate()
                    .map(|(i, h)| {
                        let block = height_to_block(*h, 4.8);
                        if sparkline_pos == Some(i) {
                            format!("\x1b[33m{}\x1b[0m", block) // Yellow for current
                        } else {
                            block.to_string()
                        }
                    })
                    .collect::<String>()
            }
            None => "────────────────".to_string(),
        };

        // Best time for selected activity
        let best_time = if app.current_activity.is_some() {
            // Calculate best time (simplified)
            "14:00".to_string()
        } else {
            "".to_string()
        };

        let name_padded = format!("{:<18}", beach.name);
        let name_style = if is_selected {
            Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)
        } else {
            Style::default().fg(Color::White)
        };

        let mut spans = vec![
            Span::styled(cursor, if is_selected { Style::default().fg(Color::Cyan) } else { Style::default() }),
            Span::styled(name_padded, name_style),
            Span::styled(temp_str, Style::default().fg(temp_color)),
            Span::raw(weather_icon_str),
            Span::raw(" "),
            Span::styled(water_icon_str, Style::default().fg(water_color)),
            Span::raw(" "),
            Span::styled(&tide_sparkline, Style::default().fg(Color::Cyan)),
        ];

        if !best_time.is_empty() {
            spans.push(Span::raw(" "));
            spans.push(Span::styled(best_time, Style::default().fg(Color::Green)));
        }

        lines.push(Line::from(spans));
    }

    let block = Block::default()
        .title(" Vancouver Beaches ")
        .borders(Borders::ALL)
        .border_style(Style::default().fg(Color::Cyan));

    let paragraph = Paragraph::new(lines).block(block);
    frame.render_widget(paragraph, area);
}

fn height_to_block(height: f64, max_height: f64) -> char {
    const BLOCKS: [char; 8] = ['▁', '▂', '▃', '▄', '▅', '▆', '▇', '█'];
    let normalized = (height / max_height).clamp(0.0, 1.0);
    let index = ((normalized * 7.0).round() as usize).min(7);
    BLOCKS[index]
}
```

**Step 3: Test and commit**

Run: `cargo run`
Verify: Sparklines appear next to each beach

```bash
git add src/ui/beach_list.rs src/data/tides.rs
git commit -m "feat: add inline tide sparklines to beach list

Each beach now shows a 16-character tide sparkline covering 6am-9pm.
Current hour is highlighted in yellow.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Phase 3: Tide Visualization (Full Charts)

### Task 8: Add Full Tide Chart to Beach Detail

**Files:**
- Modify: `src/ui/beach_detail.rs`

**Step 1: Create tide chart rendering function**

Add to `src/ui/beach_detail.rs`:

```rust
fn render_tide_chart(frame: &mut Frame, area: Rect, tides: Option<&crate::data::TideInfo>) {
    let mut lines = vec![Line::from(Span::styled(
        "TODAY'S TIDES",
        Style::default().fg(colors::HEADER).add_modifier(Modifier::BOLD),
    ))];

    match tides {
        Some(t) => {
            let heights = t.hourly_heights(4.8);
            let max_h = 4.8;

            // Create ASCII chart (5 rows of height)
            for level in (0..5).rev() {
                let threshold = (level as f64 + 0.5) / 5.0 * max_h;
                let mut row = String::new();

                // Y-axis label
                let label = format!("{:.1}m│", threshold);
                row.push_str(&label);

                // Chart bars
                for height in &heights {
                    if *height >= threshold {
                        row.push_str("██");
                    } else {
                        row.push_str("  ");
                    }
                }

                lines.push(Line::from(Span::styled(row, Style::default().fg(Color::Cyan))));
            }

            // X-axis
            let x_axis = "    └──┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬──";
            lines.push(Line::from(Span::styled(x_axis, Style::default().fg(colors::SECONDARY))));

            let hours = "       6   8   10  12  14  16  18  20";
            lines.push(Line::from(Span::styled(hours, Style::default().fg(colors::SECONDARY))));

            // Current time marker
            let current_hour = chrono::Local::now().hour();
            if current_hour >= 6 && current_hour <= 21 {
                lines.push(Line::from(vec![
                    Span::raw("                  "),
                    Span::styled("▲ NOW", Style::default().fg(Color::Yellow)),
                ]));
            }

            // Summary line
            lines.push(Line::from(vec![
                Span::styled(
                    format!("Current: {:.1}m ({}) │ ", t.current_height,
                        match t.tide_state {
                            crate::data::TideState::Rising => "rising",
                            crate::data::TideState::Falling => "falling",
                            crate::data::TideState::High => "high",
                            crate::data::TideState::Low => "low",
                        }
                    ),
                    Style::default().fg(colors::PRIMARY),
                ),
                Span::styled(
                    format!("High: {} ({:.1}m)",
                        t.next_high.as_ref().map(|h| h.time.format("%H:%M").to_string()).unwrap_or_default(),
                        t.next_high.as_ref().map(|h| h.height).unwrap_or(0.0),
                    ),
                    Style::default().fg(colors::SECONDARY),
                ),
            ]));
        }
        None => {
            lines.push(Line::from(Span::styled(
                "Tide data unavailable",
                Style::default().fg(colors::UNKNOWN),
            )));
        }
    }

    let paragraph = Paragraph::new(lines);
    frame.render_widget(paragraph, area);
}
```

**Step 2: Update beach detail layout to include chart**

Modify the layout in `render()` to add a tide chart section.

**Step 3: Test and commit**

```bash
git add src/ui/beach_detail.rs
git commit -m "feat: add full 24-hour tide chart to beach detail view

ASCII bar chart showing tide heights with:
- Y-axis labels in meters
- X-axis hour labels
- NOW marker at current hour
- Current height and next high/low summary

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

### Task 9: Add Tide Overlay to Plan Trip Grid

**Files:**
- Modify: `src/ui/plan_trip.rs`

**Step 1: Update cell rendering to include tide indicator**

In `render_heatmap_grid`, modify the cell rendering:

```rust
// In the loop that renders cells:
let tide_indicator = app.get_conditions(beach.id)
    .and_then(|c| c.tides.as_ref())
    .map(|t| {
        let heights = t.hourly_heights(4.8);
        let hour_idx = (*hour - 6) as usize;
        let height = heights.get(hour_idx).copied().unwrap_or(2.4);
        height_to_block(height, 4.8)
    })
    .unwrap_or(' ');

let cell_content = if is_cursor {
    format!("[{}{}]", tide_indicator, score)
} else {
    format!(" {}{} ", tide_indicator, score)
};
```

**Step 2: Update legend to explain tide indicators**

**Step 3: Test and commit**

```bash
git add src/ui/plan_trip.rs
git commit -m "feat: add tide height indicators to plan trip grid

Each cell now shows a small tide indicator (▁-█) alongside
the activity score, making it easy to correlate tide with
optimal times.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Phase 4: Live Updates

### Task 10: Add Background Refresh Architecture

**Files:**
- Create: `src/refresh.rs`
- Modify: `src/main.rs`
- Modify: `src/app.rs`

**Step 1: Create refresh module**

Create `src/refresh.rs`:

```rust
//! Background data refresh system

use std::time::Duration;
use tokio::sync::mpsc;

use crate::data::{BeachConditions, Weather, WaterQuality, TideInfo};

/// Messages sent from background refresh to main app
#[derive(Debug)]
pub enum RefreshMessage {
    WeatherUpdated(String, Weather), // beach_id, weather
    WaterQualityUpdated(String, WaterQuality),
    TidesUpdated(TideInfo),
    RefreshError(String), // error message
}

/// Configuration for refresh intervals
pub struct RefreshConfig {
    pub weather_interval: Duration,
    pub water_quality_interval: Duration,
}

impl Default for RefreshConfig {
    fn default() -> Self {
        Self {
            weather_interval: Duration::from_secs(300), // 5 minutes
            water_quality_interval: Duration::from_secs(1800), // 30 minutes
        }
    }
}

/// Spawns background refresh tasks
pub fn spawn_refresh_tasks(
    config: RefreshConfig,
) -> mpsc::Receiver<RefreshMessage> {
    let (tx, rx) = mpsc::channel(32);

    // Weather refresh task
    let weather_tx = tx.clone();
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(config.weather_interval);
        loop {
            interval.tick().await;
            // Refresh logic would go here
            // For now, just a placeholder
        }
    });

    rx
}
```

**Step 2: Integrate with main event loop**

**Step 3: Test and commit**

---

### Task 11: Add Real-time Clock and Countdowns

**Files:**
- Modify: `src/ui/beach_list.rs`
- Modify: `src/main.rs` (tick-based rendering)

**Step 1: Update main loop for tick-based updates**

The event loop already polls every 100ms, which is sufficient for second-level updates.

**Step 2: Update header to show live time**

The header already shows time, but we need to ensure it updates every render.

**Step 3: Commit**

---

## Phase 5: Polish

### Task 12: Add Score Transparency (Factor Breakdown)

**Files:**
- Modify: `src/ui/beach_detail.rs`

Add a function to render the score breakdown when a time window is selected.

---

### Task 13: Add Data Freshness Status Bar

**Files:**
- Modify: `src/ui/beach_list.rs`
- Modify: `src/app.rs` (track fetch timestamps)

---

### Task 14: Add Loading Progress Screen

**Files:**
- Modify: `src/main.rs`
- Create: `src/ui/loading.rs`

---

### Task 15: Add Help Overlay (? key)

**Files:**
- Modify: `src/app.rs` (add Help state)
- Create: `src/ui/help.rs`

---

### Task 16: Add Activity Selection from Home Screen

**Files:**
- Modify: `src/app.rs` (handle 1-5 keys in BeachList)
- Modify: `src/ui/beach_list.rs` (show activity in header)

---

## Testing Strategy

Each task includes specific tests. Run the full test suite after each phase:

```bash
cargo test
cargo clippy
cargo fmt --check
```

## Commit Strategy

- One commit per task
- Prefix: `feat:`, `fix:`, `refactor:`, `test:`
- Co-authored-by line on all commits

---

## Definition of Done

Phase 1 complete when:
- [ ] Sunset recommendations never suggest times after sunset
- [ ] Swimming blocked when raining or below 15°C
- [ ] Water quality shows staleness when > 48h old

Phase 2 complete when:
- [ ] Smart header shows best beach and countdown timers
- [ ] Inline tide sparklines on all beaches
- [ ] Activity selection works from home screen

Phase 3 complete when:
- [ ] Full tide chart in beach detail view
- [ ] Tide indicators in plan trip grid

Phase 4 complete when:
- [ ] Background refresh every 5 minutes for weather
- [ ] Live clock updates every second

Phase 5 complete when:
- [ ] Score breakdown visible when time selected
- [ ] Data freshness in status bar
- [ ] Help overlay on ? key
- [ ] Loading screen shows progress
